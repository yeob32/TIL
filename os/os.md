# OS

### 프로세스와 스레드의 차이

- **프로세스**
    - 실행 중인 프로그램으로, 디스크로 부터 프로그램 정보를 받아서 메모리에 할당한다.
    - Code, Data, Heap, Stack 영역으로 구분된다.
- **스레드**
    - 프로세스의 실행 단위
    - Stack 영역만 따로 할당 받고, 프로세스 내의 스레드는 Code, Data, Heap 영역을 공유한다.
    - TCB 정보를 갖고 있음 (스레드 id,PCB 주소 등등)

### 멀티스레드와 멀티프로세스

- 멀티스레드는 적은 메모리 공간을 차지하고, 컨텍스트 스위칭이 빠르다.
    - 하지만 여러 스레드 중 하나의 작업에서 오류가 발생하면 전체 스레드가 종료될 위험이 있다.
    - 동시성 제어가 필요하며, 과도한 락으로 병목이 발생하지 않도록 주의해야한다.
- 멀티프로세스 컨텍스트 스위칭과 멀티스레드 컨텍스트 스위칭
    - 멀티프로세스 컨텍스트 스위칭 : 서로 다른 프로세스의 스레드 간 컨텍스트 스위칭
    - 멀티스레드 컨텍스트 스위칭 :하나의 프로세스의 스레드 간 컨텍스트 스위칭
        - 멀티프로세스 컨텍스트 스위칭의 경우 컨텍스트 백업 뿐만 아니라 cache 메모리 초기화 등등의 작업이 있기 때문에 느리고
          멀티스레드 컨텍스트 스위칭은 메모리 주소가 변하지 않기 때문에 컨텍스트 백업만 하기 때문에 가벼움

### 컨텍스트 스위칭 (Context Switching)

- 운영체제는 프로세스 관리를 위해 프로세스 생성 시 PCB 정보를 생성한다.
- 프로세스는 CPU 를 할당 받아서 작업 중 프로세스 전환이 발생하면 작업 정보를 저장 후 CPU 에 반환해야하며, 이때 작업의 진행 상황을 PCB 에 저장한다.
  다시 CPU 를 할당 받게 되면 PCB 의 정보를 불러와서 종료 시점 부터 다시 작업을 진행한다.

### 동기와 비동기

- 동기는 블로킹으로 인해 작업을 기다려야 한다.
- 이벤트큐 또는 백그라운드 스레드에서 처리하는 작업을 비동기

## 스케줄링

- 운영체제에서 프로세스의 할당 순서 및 방법을 결정하는 것

### 스케줄러
> 프로세스가 생성되어 실행 될 때 필요한 시스템 자원을 해당 프로세스에게 할당하는 작업

### 목적
- CPU 자원 활용의 극대화

### 스케줄링
> 프로세스는 자신의 임무를 수행하고 사라질 때까지 많은 큐를 돌아다닌다.
> 스케줄러가 어떤 프로세스에게 CPU를 할당 해줄 것인지 정하는 것

### 스케줄링 큐
- Job Queue
  - 현재 시스템 내의 모든 프로세스 집합
- Ready Queue
  - 현재 메모리 내에 있으면서 CPU를 잡아서 실행되기를 기다리는 프로세스의 집합
- Device Queue
  - Device I/O 작업을 대기하고 있는 프로세스의 집합

### 스케줄러 종류
- 장기 스케줄러 (Long Term Scheduler)
  - 디스크에 저장되어 있는 프로세스들을 메인 메모리로 적재
  - 어떤 프로세스에 메모리를 할당 하여 Ready Queue 로 보낼지 결정하는 작업
  - 작업 스케줄링, 상위 스케줄링이라고도 하며, 작업 스케줄러에 의해 수행
  - 프로세스 상태 전이
    - new -> ready
- 단기 스케줄러 (Short Term Scheduler)
  - Ready Queue 에 존재하는 먼저 도착한 프로세스에게 CPU 할당 (Dispatch)
  - CPU 와 메모리 사이의 스케줄링을 담당.
  - 프로세스 상태 전이
    - ready -> running
- 중기 스케줄러 (Medium Term Scheduler)
  - 프로세스들이 서로 CPU를 차지하려고 경쟁이 심해지면, swapping으로 메모리 관리
  - 메모리에서 CPU를 쓰기 위한 경쟁 프로세스들을 어느 정도 제거, 나중에 다시 메모리로 불러와 중단된 지점을 다시 실행 (swapping)
  - swapping 기법
    - swap out : 메모리에서 디스크로 잠시 나가는 상태
    - swap in : 디스크에서 메모리로 다시 들여오는 상태

### 스케줄링
- 선점형 스케줄러 (Preemptive Scheduling)
  - 하나의 프로세스가 다른 프로세스 대신에 프로세서(CPU)를 차지 할 수 있음
  - 프로세스 running 중에 스케줄러가 이를 중단시키고, 다른 프로세스로 교체 가능
- 비선점형 스케줄러 (Non-Preemptive Scheduling)
  - 하나의 프로세스가 끝나지 않으면 다른 프로세스는 CPU를 사용할 수 없음
  - 프로세스가 자발적으로 blocking 상태로 들어가거나, 실행이 끝났을 때만 다른 프로세스로 교체 가능

### 스케줄링 알고리즘
- 비선점
  - 선입 선처리 스케줄링 (FCFS, First Come First Served or FIFO Scheduling)
    - 구현이 간단하다.
    - Ready queue 에 도착한 순서대로 CPU 할당
    - 소요시간이 긴 프로세스가 먼저 도달하여 효율성을 낮추는 현상 발생 가능
  - 최소작업 우선 스케줄링 (SJF, Shortest Job First Scheduling)
    - 큐 안에 있는 프로세스 중에서 수행시간이 짧은 것부터 먼저 수행
    - 평균 대기 시간 줄어듬
    - 수행시간이 긴 프로세스는 영원히 CPU를 할당 받지 못 할 수도 있다. (starvation)
- 선점
  - 라운드 로빈 스케줄링 (Round Robin Scheduling)
    - 각 프로세스는 동일한 크기의 CPU 시간 할당
    - 할당 시간이 지나면 프로세스는 선점당하고 Ready Queue 의 제일 뒤로 감 (원형 큐)
    - 모든 프로세스가 공정하게 시간을 할당받기에 starvation 이 발생하지 않음
    - 프로세스 최악의 응답시간을 아는데 용이
    - 작업 시간을 너무 짧게 하면 Context Switching 이 자주 일어나 오버헤드 발생
- 우선순위 스케줄링 (Priority Scheduling)
  - Ready Queue 의 프로세스 중 우선순위가 가장 높은 프로세스에 CPU 할당
  - 선점 우선순위
    - 더 높은 우선순위의 프로세스가 도착하면 실행중인 프로세스 멈추고 CPU 선점
  - 비선점 우선순위
    - 더 높은 우선순위의 프로세스가 도착하면 Ready Queue 제일 앞(Head)에 넣어준다.
  - 오래 대기하는 프로세스는 우선순위를 점진적으로 증가 (aging)

## 페이지 교체

- 메모리에 올라와 있는 페이지 중 하나를 디스크로 쫓아내어 메모리 공간을 확보하는 작업
- 페이지를 교체 할 때, 어떤 프레임에 있는 페이지를 쫓아낼 것인지를 결정하는 알고리즘

### 페이지 교체 알고리즘

- FIFO (First-In-First-Out)
    - 가장 오래된 페이지를 교체
    - 각 페이지 올라온 시간을 페이지에 기록하거나 페이지가 올라온 순서를 Queue에 저장
    - 활발하게 사용 중인 페이지를 계속 교체한다면 페이지 부재율이 높아지고 성능 저하 발생
- LRU (Least Recent Used)
    - 가장 오랫동안 사용 되지 않은 페이지 교체
    - 최적 알고리즘과 비슷한 효과
    - 가장 많이 쓰임.
- LFU (Least-Frequently-Used)
    - 참조 횟수가 가장 적은 페이지 교체
    - 교체 대상 페이지가 여러 개 일 경우 가장 오랫동안 사용 되지 않은 페이지 교체(LRU)
- 최적 페이지 교체 (Optimal Page Replacement)
    - 앞으로 가장 오랫동안 사용 되지 않을 페이지 교체
    - 프로세스가 앞으로 사용할 페이지를 알아야 한다. 구현 불가.
    - 페이지 교체 수가 가장 적다.
- MFU (Most-Frequently-Used)
    - 참조 횟수가 가장 많은 페이지 교체
    - 참조 횟수가 가장 적은 페이지가 최근에 사용된 것이기 때문에 앞으로 사용될 가능성이 높다는 판단

`LFU` 와 `MFU` 는 잘 쓰이지 않는다 => 구현이 어렵고 비용이 많이 든다.

## 메모리 단편화 (Memory Fragmentation)

- 메모리의 빈공간 또는 자료가 여러개의 조각으로 나뉘는 현상
- RAM 에서 메모리의 공간이 작은 조각으로 나뉘어져 사용 가능한 메모리가 충분히 존재하지만 사용(할당)이 불가능한 상태

#### 내부 단편화 (Internal Fragmentation)

- 메모리를 할당할 때 Process 가 필요한 양보다 더 큰 메모리가 할당되어서 메모리 공간이 낭비되는 상황

#### 외부 단편화 (External Fragmentation)

- 총 할당 가능한 자원의 합에 비해 실제 할당 할 수 있는 자원의 크기가 작은 상태

#### 해결 방법

- 메모리 압축 (Memory Compaction)
    - 여러 곳에 분산되어 있는 단편화된 메모리 공간들을 결합하여 하나의 큰 공간으로 만듬 (디스크조각모음)
    - CPU가 몇 개의 바이트씩 읽어오고 다시 쓰는 방법으로 반복해서 재배치(Compaction) 하기 떄문에 CPU 처리시간이 증가하여 처리기 효율이 크게 감소한다.
- 메모리 통합 (Memory Coalescint)
    - 단편화가 발생된 공간에서 인접해있는 다른 단편화 공간들을 하나로 통합시켜 큰 공간으로 만드는 기법
- 페이징 (Paging)
    - 필요한 메모리는 페이지 단위로 프레임에 올리고 사용하지 않는 프레임은 페이지로 옮기는 기법
    - 페이지
        - 가상기억장치(가상메모리)를 모두 같은 크기의 블록으로 편성하고 이 일정한 크기인 블록
    - 프레임
        - 주소공간을 페이지 단위로 나누고 실제 기억공간(RAM)은 페이지 크기와 같은 크기의 블록
    - 사용하는 메모리는 프레임에 올리고 사용하지 않는 메모리는 페이지에 저장
    - 가상메모리 사용, 외부단편화 해결, 내부단편화 발생
- 세그멘테이션 (Segmentation)
    - 가상기억장치(가상메모리)를 서로 크기가 다른 논리적 단위인 세그먼트로 분할하고 메모리를 할당하며 주소변환을 하는 기법
    - 세그먼트들의 크기가 서로 다르기 때문에 메모리를 페이징 기법에서처럼 미리 크기를 잡아둘 수 없고,
      메모리에 적재될 때 빈공간을 찾아 할당하는 사용자 관점의 가상 메모리 기법이다.
    - 가상메모리 사용, 외부단편화 발생, 내부단편화 해결
- 메모리 풀 (Memory Pool)
    - 필요한 메모리 공간을 크기/개수 만큼 사용자가 직접 지정하여 받아 놓고, 사용하고 반납하는 기법
    - 외부 단편화, 내부단편화 해결

## Deadlock (교착 상태)

- 두 개 이상의 작업이 서로 상대방의 작업이 끝나기 만을 기다리고 있어 결과적으로 아무것도 완료되지 못하는 상태

#### 발생 조건
> 4가지 조건 모두 만족 시 교착 상태 발생
- 상호 배제 (Mutual exclusion)
  - 자원은 한 번에 한 프로세스만이 사용 할 수 있어야한다.
- 점유 상태로 대기 (Hold and wait)
  - 자원을 점유한 상태에서 다른 자원의 점유를 기다린다.
- 선점 불가 (No preemption)
  - 다른 프로세스에 할당된 자원은 사용이 끝날 때 까지 강제로 뺏을 수 없어야 한다.
- 순환성 대기 (Circular wait)
  - 프로세스 자원과 요구가 원형을 이루는 상태

#### 해결
- 예방 (Prevention)
  - 교착상태 발생 가능성을 사전에 모두 제거 (4가지 부정)
  - 가장 명료하고 널리 사용되나 자원의 낭비가 크다
- 회피 (Avoidance)
  - 교착상태 발생 가능성을 배제하지 않고 적절하게 회피 (ex. 은행원 알고리즘)
- 발견 (Detection)
  - 교착상태 발생을 허용하고 발생 시 원인을 규명하여 해결 (ex. 자원할당 그래프)
- 복구 (Recovery)
  - 교착상태의 프로세스를 식별하여 중지하고 재할당 (ex 프로세스 종료, 자원 선점)

## 프로세스 동기화

- 협력하는 프로세스들 사이의 실행 순서 규칙 보장
- 공유 자원 일관성(consistency) 보장

### 임계 영역 (Critical Section)
- 여러 프로세스나 스레드 등의 처리 단위가 동시에 접근해서는 안되는 공유 영역

```
do {
    wait(mutex); // 입장 영역(entry section)

    임계 영역

    signal(mutex); // 퇴장 영역(exit section)

    나머지 영역(remainder section)
}
```

### 임계 영역 문제
- 임계 영역에 두 처리 단위가 동시에 접근 할 때 발생하는 문제

### 관련 문제
- 입출금 문제
- 생산자-소비자 문제
- 독자-저자 문제

### 해결 조건
> 임계 구역 문제를 해결하기 위해서는 다음 3가지 조건을 충족해야 한다.
- 상호 배제(Mutual exclusion)
  - 하나의 프로세스가 임계 구역에 들어가 있다면 다른 프로세스는 들어갈 수 없어야 한다.
- 진행(Progress)
  - 임계 구역에 들어간 프로세스가 없는 상태에서, 들어가려고 하는 프로세스가 여러 개 있다면 어느 것이 들어갈지를 적절히 결정해주어야 한다.
- 한정 대기(Bounded waiting)
  - 다른 프로세스의 기아(Starvation)를 방지하기 위해, 한 번 임계 구역에 들어간 프로세스는 다음 번 임계 구역에 들어갈 때 제한을 두어야 한다.

### 해결 방법
- 소프트웨어
  - 피터슨의 알고리즘
- 하드웨어
  - 세마포어
  - 모니터

### 동기화 기법
- 뮤텍스 (Mutex)
  - 상호 배제(`Mut`ual `Ex`clusion) 줄여서 `Mutex`
  - 두 처리 단위가 임계 영역에 동시에 접근하지 못하도록 막는 기법
  - 즉, 뮤텍스 객체를 두 스레드가 동시에 사용할 수 없다는 의미
  - 단순 구현
    - lock
      - 현재의 임계 영역에 들어갈 권한을 얻어온다.
      - 만일 다른 프로세스/스레드가 임계 영역을 수행 중이라면 종료할때까지 대기한다(entry section).
    - unlock
      - 현재의 임계 영역을 모두 사용했음을 알린다.
      - 대기중인 다른 프로세스/스레드가 임계 영역에 진입할 수 있다(exit section).
- 세마포어 (Semaphore)
  - 원자적으로 제어되는 정수 변수
  - 여러 프로세스나 스레드가 공유 자원에 접근하는 것을 제어하기 위한 방법
  - 일반적으로 세마포어의 값이 0이면 자원에 접근할 수 없도록 블럭을 하고 0보다 크면 접근함과 동시에 세마포어의 값을 1 감소시킨다.
  - 종류
    - 계수 세마포어 (counting semaphore)
      - 초기값은 가능한 자원의 수로 정해진다.
      - 값의 범위는 정해져 있지 않다.
    - 이진 세마포어 (binary semaphore)
      - 0 또는 1
  - 싱글톤 패턴은 일종의 세마포어를 활용한 공유 자원 관리 기법

#### 세마포어, 뮤텍스 차이
- 관리하는 동기화 대상의 개수
- 뮤텍스는 동기화 대상이 오직 하나 뿐일 때
- 세마포어는 동기화 대상이 하나 이상일 때

#### 모니터 (Monitor)
- 프로세스 또는 스레드를 동기화하는 방법
- 고급 언어의 설계 구조물로서, 개발자의 코드를 상호배제 하게끔 만든 추상화된 데이터 형태
- 한번에 하나의 프로세스만 모니터에서 활동하도록 보장
- 자바의 스레드 관련 라이브러리와 그 기능(wait, join, notify 등)

#### Lock
- 하드웨어 기반 해결책
- 동시에 공유 자원에 접근하는 것을 막기 위해 Critical Section 에 진입하는 프로세스는 Lock 을 획득하고 Critical Section 을 빠져나올 때, Lock 을 방출함으로써 동시에 접근이 되지 않도록 한다.

#### 참고
- https://namu.wiki/w/뮤텍스