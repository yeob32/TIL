# 캐시

#### Hot key

- 자주 참조되거나 수정될 수 있는 key
- 주로 sharding 시 RDBMS, key-value NoSQL 등에서 많이 참조되는 key,record
    - sharding 시 key 의 분배가 개수적으로잘 이루어져도 해당 key 가 자주 참조 되기 때문에 불균형 문제 발생 가능

#### cache hit

- 캐싱된 데이터가 있을 경우 바로 가져옴

#### cache miss

- 캐싱된 데이터가 없을 경우 DB에서 가져옴

### 주의 사항

- 휘발성
- 용량 부족

## 캐싱 전략

- 웹 서비스 환경에서 시스템 성능 향상을 기대할 수 있는 중요한 기술
- 적절한 캐시 전략을 통해 데이터 정합성 문제 해결

### 캐시 읽기 전략 (Read Cache Strategy)

#### Look Aside 패턴 (Cache Aside)

- 캐시에 저당된 데이터가 있는지 우선적으로 확인 후 없다면 데이터베이스를 조회하는 전략
- 반복적인 읽기 작업에 적합
    - 초기 조회 시 데이터베이스를 조회해야하며, 단건 호출이 잦은 작업에는 적합하지 않음
    - Cache Warming
        - 데이터베이스의 데이터를 미리 캐시에 올려두는 작업
- 캐시 서버가 다운되어도 데이터베이스가 동작하기 때문에 장애 대응 가능
    - 캐시 서버가 다운된다면 DB 서버에 부하 발생 가능성
- 캐시와 DB 가 분리되어있기 떄문에 특정 데이터만 별도의 캐시로 구성할 수 있음

#### Read Through 패턴

- 캐시에서만 데이터를 읽어오는 전략
- 데이터 동기화를 라이브러리 또는 캐시 제공자에게 위임, Look Aside 와 비슷함
    - 캐시 스토어에서 데이터베이스를 직접 조회함
- 캐시 서버 다운 시 장애로 이어질 위험
    - Cluster 또는 Replication 을 구성해서 가용성을 높여야함
- 캐시와 데이터베이스 간의 데이터 동기화가 항상 이루어지기 때문에 데이터 정합성 문제 해결
- 서버에서 데이터베이스에 직접적인 접근을 최소하하기 때문에 읽기 리소스 또한 최소화

### 캐시 쓰기 전략 (Write Cache Strategy)

#### Write Back 패턴 (Write Behind)

- 캐시를 모아놓고 일정 주기의 배치 작업을 통해 DB 반영
    - 쓰기 쿼리 회수 비용과 부하를 줄일 수 있음
- 쓰기가 빈번하면서 읽기를 하는데 많은 양의 리소스가 소모되는 서비스에 적합
- 캐시 장애시 데이터 유실 위험

#### Write Through 패턴

- 캐시에 데이터를 저장 후 바로 디비에도 저장하는 전략
    - 캐시와 DB 에 바로 저장하여 데이터 일관성 유지
    - 데이터 유실이 안되는 상황에 적합
- DB 에 저장하는 작업을 캐시에 위임
- 캐시의 상태는 항상 최신 상태를 유지한다.
- 캐시와 DB 에 매요청 마다 저장을 하기 때문에 성능 이슈 고려
- 자주 사용되지 않는 불필요한 리소스까지 저장하게 될 수도 있음

#### Write Around

- DB 에만 저장하기 떄문에 성능이 매우 좋음 (캐시 갱신 안함)
- Cache miss 가 발생하는 경우에만 캐시와 DB 에 데이터 저장
    - 때문에 데이터 정합성 이슈가 있음

### 읽기 + 쓰기 전략

#### Look Aside + Write Around

- 일반적으로 자주 쓰임

#### Read Through + Write Through

- 데이터를 쓸 때 항상 캐시에 먼저 쓰기 떄문에 읽어올 때 최신 캐시 데이터를 보장
- 데이터를 쓸 때 항상 캐시에 먼저 쓰고 DB로 보내므로 데이터 정합성 보장

#### Read Through + Write Around

- 데이터를 DB 에 저장하고 데이터를 가져올 때 항상 캐시에서 DB 를 조회하므로 데이터 일관성 보장 가능

## Cache Stampede

- 캐시 만료로 인해 많은 데이터 조회 요청이 갑자기 DB 로 몰리는 현상
- 키가 만료되는 순간 많은 트래픽 요청이 있다면 모든 애플리케이션에서 DB 를 조회하게 되어 duplicate read 발생
- 또한 읽어들인 값을 동시에 캐시에 쓰게 될 때 duplicate write 발생
    - 불필요한 작업으로 성능 저하 유발

### 해결 방안

#### 주기적인 Batch 작업을 통한 key 갱신

- 특정 Hot key 목록을 만들어두고 해당 key 는 TTL 을 설정하지 않고 DB 로 부터 주기적으로 갱신
- 장점
    - 만료가 되지 않음을 보장
    - Cache Stampede 가 발생하지 않도록 확실하게 방지
- 단점
    - 추가적인 Batch 프로세스 구현 필요
    - Hot key 관리 포인트 증가

#### Lazy Loading (Cache Miss) 이 발생하는 경우 Lock 을 사용

- Cache Miss 가 발생하여 DB 를 직접 조회해야할 때 Lock 을 활용할 수 있음
- Lock 을 획득하지 못한 요창은 해당 요청이 끝날때까지 대기
- 장점
    - 중복 조회,수정 발생 방지
- 단점
    - 캐시 만료 시 요청들이 Lock 획득을 위해 대기해야하기 때문에 병목 발생 가능성

#### Probabilistic Early Expiration (PER)

- 확률적 알고리즘을 활용하여 TTL 만료 전에 재갱신
- 장점
    - TTL 만료 자체를 연장할 수 있기 떄문에 연장이 지속적으로 이루어진다면 만료 시 생길 수 있는 문제를 완벽하게 해결 가능
    - Hot key 라면 재갱신 확률이 자동적으로 높아지기 때문에 별도로 Hot key 를 관리할 필요가 없음
- 단점
    - 확률적으로 갱신하기 때문에 최악의 경우 TTL 에 도달하여 Cache Stampede 발생 가능
    - 최악의 경우를 대비하여 미리 부하테스트를 진행해야하고 적절한 확률상수 등을 정해야한다.

## 캐시 구현체 비교

|         | Ehcache                                                                    | 	Caffein                        | 	Redis                                         | 	Memcached                 |
|---------|----------------------------------------------------------------------------|---------------------------------|------------------------------------------------|----------------------------|
| Type    | Local                                                                      | Local                           | Global                                         | Global                     |
| Base    | Off Heap Memory                                                            | In Memory                       | In Memory                                      | In Memory                  |
| Thread  | Thread-safe X                                                              | Thread-safe                     | Single Thread                                  | Multi Thread               |
| Share   | O                                                                          | X                               | O                                              | O                          |
| JSR-107 | O                                                                          | O                               | Redis Client                                   | Redisson                   |?|
| 삭제 알고리즘 | LRU(Least Recent Used) LFU (Least Frequency Used) FIFO(First In First Out) | Window TinyLfu 제거 정책            | TTL, LRU,LFU, RANDOM                           | TTL, LRU                   |
| 장점      | 기능이 많다.                                                                    | Local Cache 중 저장, 제거 성능이 가장 좋다. | 데이터 영구 보존 가능채팅, 실시간 스트리밍, SNS 피드, 서버 상호 통신에 유리 | 간단하다. 빠르다                  |
| 단점      | Caffein 대비 성능이 낮다.설정이 번거롭다.                                                | 단순 캐시 기능만 제공한다.                 | 메모리 파편화, 단일 스레드 등 기본 기능을 보강해야 하는 부분이 많음        | 데이터 영구 보존 불가 String만 저장 가능 |