# Kafka

## Kafka 란

- 분산 이벤트 스트리밍 플랫폼
- 대용량의 실시간 로그 처리에 특화 (고성능)
- 병렬처리, 확장, 고가용성 용이 (클러스터링)
- 브로커,프로듀서,컨슈머로 이루어진 Pub/Sub 모델
- 파일 시스템에 데이터 저장 (영속성)

### Leader & Follower

- 프로듀서,컨슈머는 리더를 통해서만 메세지 처리
- 팔로워는 리더가 속한 브로커에서 메세지 복제
- 리더가 속한 브로커 장애시 팔로워가 리더가 됨

## 컨슈머 그룹 리밸런싱

- 컨슈머는 각 파티션의 메세지를 처리하는데, 컨슈머에 문제가 생겼을 때 해당 파티션의 소유권을 다른 컨슈머로 이관하는 조정 작업
- 언제 발생하는가?
    - 컨슈머 배포 과정에서 앱이 재기동 될 때 기존 컨슈머가 삭제/생성 시 두 번 발생
    - 컨슈머는 일정 시간 동안 `max.poll.records` 설정 개수만큼 메세지를 처리하고 poll 요청을 보내게 된다. 만약 메세지 처리가 지연되어서 `max.poll.interval.ms`  설정
      시간을 넘어선다면, 컨슈머에 문제가 있다고 보고 리밸런싱 발생
    - 컨슈머에 문제가 생겨 일정 시간 heartbeat 를 보내지 못하면, 문제가 있다고 보고 컨슈머 그룹에서 제외 후 리밸런싱 진행
- 리밸런싱 리스크
    - 리밸런싱이 발생한 컨슈머 그룹 내의 모든 컨슈머의 읽기 작업은 일시 중단됨
    - `max.poll.records` 가 500 일 때 컨슈머에서 400개의 메세지 처리 후 문제가 발생하여 `max.poll.interval.ms` 을 넘어서게 된다면 offset 을 commit 하지
      못하고 리밸런싱 발생하여 소유권을 넘겨받은 컨슈머에서 마지막으로 커밋된 지점부터 다시 처리하여 메세지 중복이 발생한다.
- 해결 방법
    - `max.poll.records` 값을 작게 설정하여 리밸런싱 시간을 단축한다.
        - `max.poll.records` 을 작게 설정하면 성능이 떨어짐, 요청이 많은 작업이 아니라면 사용해도 괜찮음
    - 중복 컨슈밍 방어 로직 작성
    - 카프카 컨슈머 병렬 처리
        - concurrency 사이즈를 조정한다. 파티션 3, 컨슈머 2 인 경우 효과 있으나, 파티션과 컨슈머 개수가 동일하다면 의미 없음

## Kafka 운영

- kafka 메세지 순서 보장 (프로듀서)
    - key 가 전달되지 않은 경우 라운드로빈으로 파티션 선택
    - 키가 존재한다면 키를 해싱하여 해시된 값에 따라 파티션으로 분배
- kafka 중복 메세지 발생 시
    - redis 메세지 키 저장 후 존재한다면 처리 안함
    - 메세지 처리 보장 수준
        - 기본적으로는 at-least-once → 멱등성 지켜서 개발
        - exactly-once
- Partition 설정
    - 파티션 개수 ≥ 컨슈머, 파티션 개수가 늘어나면 컨슈머도 늘려야됨
    - key 를 이용해서 운영중이라면 파티션 수 변경 시 주의해야됨
- Replication Factor 설정
    - RF 의 경우 데이터 중요도에 따라 2~3개

```json
{
  "version": 1,
  "partitions": [
    {
      "topic": "peter-topic",
      "partition": 0,
      "replicas": [
        1,
        2
      ]
    },
    {
      "topic": "peter-topic",
      "partition": 1,
      "replicas": [
        2,
        3
      ]
    }
  ]
}
```

- replicas 앞에 있는 번호가 리더임, RF 변경 시 리더 정보가 변경되지 않도록 주의해야함
- 컨슈머 상태와 오프셋 확인
    - Lag 가 계속 증가한다면 컨슈머에 문제가 없는지, 증설해야할지 확인해봐야한다.
- 카프카 스케일 아웃
    - 신규 브로커가 추가되면 토픽의 파티션 재분배 작업을 해줘야 새로운 브로커도 같은 클러스터로서 역할을 할 수 있음

## 카프카 순서 보장

### Kafka Producer Load Balancing

> targetPartition = Math.abs(Utils.murmur2(keyBytes)) % (numPartitions −1)

- 클라이언트는 메세지를 어느 파티션에 게시할지 제어 가능
- 로드밸런싱을 구현하여 무작위로 수행하거나, 시맨틱 파티셔닝 함수를 통해 수행
    - 시맨틱 파티셔닝
        - 사용자가 키를 지정하는 경우 DefaultPartitioner 가 키에 대한 해시를 처리
        - key 를 포함하여 데이터를 보내면 key 의 해시값을 기준으로 파티션 선택 (keyBytes != null)
        - 2.4 이전에 사용자가 키를 지정하지 않은 경우에는 Round Robin 정책으로 동작
        - 2.4 이후에는 Sticky 정책으로 동작
            - 하나의 Batch 가 닫힐 때까지 하나의 파티션에게 record 를 보내고 랜덤으로 파티션 선택

### 파티션 수를 늘리면 파티션 순서 보장은?

- 파티션을 선택하는 식에 파티션 개수가 있기 때문에 파티션을 추가하면 결과값이 달라질 수 있음
- 만약을 위해 1~2년 후의 미래 목표 처리량을 기준으로 파티션 수 결정
- 순서보장이 필수라면, 파티션을 추가하는 대신 새로운 토픽을 만들어 데이터를 마이그레이션 필요
    - 파티션 감소 시키는 방법도 마찬가지

## Kafka Streams

- 카프카에서 공식적으로 지원하는 자바 라이브러리
- 데이터 유실과 중복처리 없이 정확히 한번만 수행되는 것을 보장한다.
- 실시간 내부 스트림 처리 시 고려 1순위
- RocksDB 기반 상태저장소 사용

### Streams DSL

- KStream
    - 레코드의 흐름을 표현한 것
    - 키, 메세지로 구성
    - KStream 으로 데이터 조회하면 모든 데이터를 조회함
- KTable
    - 메세지 키를 기준으로 묶어서 사용
    - 메세지 키 기준으로 가장 최신 데이터만 조회함

### Processor API

### Broker 스펙 비교

|              | SQS                                                             | 	SNS                               | 	Kafka                                         | 	RabbitMQ                     |
|--------------|-----------------------------------------------------------------|------------------------------------|------------------------------------------------|-------------------------------|
| 오픈소스         | 	-                                                              | 	-                                 | 	오픈소스                                          | 오픈소스                          |
| 브로커 구분       | 	메시지 브로커                                                        | 	메시지 브로커                           | 	이벤트 브로커                                       | 메시지 브로커                       |
| Queue/Topic  | 	Queue                                                          | 	Topic                             | 	Topic                                         | Queue                         |
| 동기/비동기       | 	둘 다 가능                                                         | 	비동기	                              | 비동기                                            | 둘 다 가능                        |
| 메시지 전달 보장 수준 | 	At least once(Standard)<br>Exactly once(FIFO)                  | 	메시지 전달 후 삭제하기 때문에 상실 가능           | 	At most once<br>At least once<br>Exactly once | At most once<br>At least once |
| 메시지 순서 보장 수준 | 	Standerd - Best effort <br>FIFO - 순서 보장                        | 		                                 | 한 컨슈머 그룹 기준으로 파티션의 메시지는 순서 보장                  | 하나의 큐에 하나의 컨슈머 연결시 순서 보장      |
| 모니터링         | 	SQS 콘솔 <br> Cloud Watch 콘솔 이용 가능                               | SQS 콘솔 <br> Cloud Watch 콘솔 이용 가능		 | 모니터링 오픈소스 연동해야함                                | 모니터링 오픈소스 연동해야함               |
| 성능           | 	300TPS                                                         | 무제한TPS                             | 	100000TPS                                     | 	20000TPS                     |
| 개발 언어        | 	-                                                              | 	-                                 | 	Scala                                         | Erlang                        |
| 프로토콜         | 	 | 	HTTP, HTTPS, SMTP, SMS, SQS, application, lambda and firehouse          |   Binary protocol over TCP                                             |  AMQP, MQTT, STOMP                             |