# Database

## 데이터베이스 종류

| 구분	              | 종류	                                | 특징	                                                                                               | 용도                                      |
|------------------|------------------------------------|---------------------------------------------------------------------------------------------------|-----------------------------------------|
| Relation DB      | 	Mysql, Oralcle, MSSQL, PostgreSQL | 	ACID Transaction 제공<br>데이터 정합성<br>정규화                                                            |                                         |
| Document DB      | 	MongoDB, CouchDB                  | 	Collection - Table<br>Document - Row <br> 데이터 분산 처리 용이 (분산은 곧 복제)<br>수평 확장 용이 <br> 입출력 용이<br> 데이터 일관성 부족 |                                         |
| Key-Value DB     | 	Redis                             | 		                                                                                                | 자주 쓰는 데이터 캐싱                            |
| Colomn-family DB | 	cassandra, Hbase                  | 	rdb 랑 비슷한데 row 다다 컬럼 상이<br>일반적으로 정규화 안함<br>데이터 분산 처리 용이 (분산은 곧 복제)<br>입출력 용이<br>데이터 일관성 부족       |
| Graph DB         | 	neo4j                             | 		                                                                                                | 비행기 노선<br>SNS 친구 관계<br>코로나 전염맵<br>추천서비스 |
| Search Engine    | 	ElasticSearch                     |                                                                                                   |                                         |

## Index

DB의 테이블에 데이터가 많을 때, 검색 속도를 향상시켜주기위해 사용

### 특징

- 검색 속도의 향상 효과
- 시스템 부하를 줄여, 시스템 전체 성능향상에 기여
- index를 위한 추가 공간 필요, 데이터가 많다면 생성에 많은 시간이 소요 될 수 있다.
- INSERT, UPDATE, DELETE가 자주 발생한다면 성능 하락 - 크게 이슈 없다.

### Clustered Index

- AI PK 는 정렬이 되어있기 때문에 인덱스 설정 필요없다.
- Index를 생성할 때는 데이터 페이지 전체를 다시 정렬
- 데이터 삽입, 수정, 삭제시 테이블의 데이터를 정렬

### Non-Clustered Index

- 물리적으로 행 재배열 x
- 테이블당 여러개

### Binary Search Tree

이진 탐색 트리는 데이터를 트리 형태로 구성하는 자료구조입니다. 트리의 각 노드는 최대 두 개의 자식 노드를 가지며, `left` 자식 노드는 항상 노드보다 작고, `right` 자식 노드는 항상 노드보다 큽니다.
이 속성은 이진 탐색 트리를 데이터 검색에 효율적인 구조로 만듭니다.

### B-Tree

B-Tree은 파일 시스템이나 데이터베이스에서 대량의 데이터를 저장하는 데 사용되는 자체 균형 이진 탐색 트리입니다. B-Tree의 디자인은 노드의 효율적인 검색, 삽입 및 삭제를 가능하게 합니다.

### B+Tree

B+트리는 B-트리와 유사한 자료구조이며 키와 데이터를 모두 가지고 있는 리프 노드와 키의 인덱스만을 가지고 있는 내부 노드로 구성됩니다. 내부 노드는 자식 노드와 함께 키의 범위를 나타내는 역할을 하며, 리프
노드는 실제 데이터를 저장하고 범위 검색과 정렬에 효율적입니다.

## 정규화

### Nomalization

시스템 확장성 증가

속성 분해로 Join 연산 증가 → 성능 저하 → 역정규화

### ex) id, name, grade, discount

### 1정규화

한 컬럼에 하나의 데이터, like 검색 하도록 지양

ex) 유형 같은 데이터를 특정 문자열로 구분한다.

grade → vip, gold, silver ROW 3개

### 2정규화

연관 데이터는 테이블로 분리하여 참조하도록 한다.

학생 - 학부와 같이 학부 이름이 바뀐다면,,

즉, 테이블의 핵심 주제(기본키)와 관련 없는 컬럼은 분리한다.

ex) grade 테이블 분리

### 3정규화

기본키를 제외한 속성들 간의 종속을 제거한다.

ex) grade, discount 테이블 분리하고 discount 는 id 와 연관이 없어야함

## 파티셔닝, 샤딩

데이터베이스 볼륨이 커지면 커질수록 데이터베이스 읽기/쓰기 성능은 감소, 병목으로 이어짐

거대한 데이터셋을 서브셋으로 분리하여 관리하는 방법

## 파티셔닝

파티셔닝은 매우 큰 테이블을 여러개의 테이블로 분할하는 작업

- 큰 데이터를 여러 테이블로 나눠 저장하기 때문에 쿼리 성능이 개선
- 물리적으로 여러 테이블로 분산
- 하나의 테이블에 접근하는 것과 같이 사용
- 모든 데이터를 동일한 컴퓨터에 저장

### MySQL 파티셔닝 지원

- InnoDB, NDB
- MyISAM 지원 X

### 파티셔닝 종류

- List Partitioning
    - 데이터 값이 특정 목록에 포함된 경우 데이터를 분리
- Range Partitioning
    - 데이터를 특정 범위 기준으로 분할
- Hash Partitioning
    - 해시 함수를 사용하여 데이터를 분할
- Composite Partitioning
    - 파티셔닝 종류 2개 이상 사용하는 방식

## 샤딩

동일한 스키마를 가지고 있는 여러대의 데이터베이스 서버들에 데이터를 작은 단위로 나누어 분산 저장

작은 단위를 샤드(shard) 라고 함

- 수평 파티셔닝
- 일종의 수평 확장(scale-out)
- 데이터를 서로 다른 컴퓨터에 분산 → 부하 분산
- 데이터베이스 차원이 아닌**애플리케이션 레벨에서 구현하는 것이 일반적**
- 여러 샤드에 걸친 데이터를 조인하는 것은 어려움
- 한 데이터베이스에 집중적으로 데이터가 몰리면 Hotspot이 되어 성능 저하
    - 데이터를 여러 샤드로 고르게 분배하는 것이 중

### 샤딩 종류

- Hash Sharding
    - Hash Sharding 중 나머지 연산을 사용한 Modular Sharding 을 알아본다
    - Modular Sharding은 PK값의 모듈러 연산 결과를 통해 샤드를 결정하는 방식
    - 총 데이터베이스 수가 정해져있을 때 유용
    - 데이터베이스 개수가 줄어들거나 늘어나면 해시 함수도 변경해야하고, 따라서 데이터의 재 정렬이 필요
- Range Sharding
    - PK 값을 범위로 지정하여 샤드를 지정하는 방식
    - 증설 작업에 큰 리소스가 소요되지 않음
        - 급격히 증가할 수 있는 성격의 데이터 용도에 적합
    - 특정한 데이터베이스에만 부하가 몰릴 수 있음

## 확장

### 수직 확장 (scale-up)

단일 서버의 스펙 업그레이드

일반적으로 데이터 일관성,무결성이 중요한 용도에 적합 ex) RDB

- 간단함
- 데이터 일관성 유지 비용 발생하지 않음
- 수직 확장의 한계 명확
- 요구 스펙 수준이 높아질 수록 더 큰 비용 발생
- 업그레이드 시 다운 타임 발생
- 하나의 서버로 부하 집중 → 단일 장애점

```
id | name | email
1 | a | === a@abc.com
2 | b | === b@abc.com
3 | c |  === c@abc.com
4 | d |  === d@abc.com

id | name
1 | a 
2 | b
3 | c
4 | d

id | email
1 | a@abc.com
2 | b@abc.com
3 | c@abc.com
4 | d@abc.com
```

### 수평 확장 (scale-out)

여러대의 서버를 추가로 설치

- 클러스터링 비용 추가 발생 (로드 밸런서)
    - 기술적,관리적으로 까다롭고 어려움
- 무한대로 확장 가능
- 확장이 유연함
- 수평의 데이터를 다수의 테이블로 분할.
- 여러 샤드를 넘나드는 쿼리 실행 불가능 (내부 서버 데이터만 조인 가능)

- 샤딩 (= 수평 파티셔닝)
    - 수평의 데이터를 다수의 테이블로 분할.
    - 여러 샤드를 넘나드는 쿼리 실행 불가능 (내부 서버 데이터만 조인 가능)
```
id | name | email
    1 | a | a@abc.com
    2 | b | b@abc.com
    ================== 테이블로 분할
    3 | c | c@abc.com
```


### 다중화

Master-Slave 관계로 구성, 원본을 slave 로 복제한다.

쓰기 보다 읽기 연산 비중이 크다.

- 성능 향상
    - 병렬로 처리되는 쿼리의 수가 늘어나므로 성능이 향상
        - Write 연산은 Master , Read 는 Slave
- 안정성
    - 서버 일부가 파괴되어도 데이터 보존
- 가용성
    - 서버 일부가 다운 되어도 계속 서비스 가능

## CAP 이론

네트워크로 분산된 데이터베이스 시스템 일관성,가용성,분할 내구성 의 3가지 특성 중 2가지만 충족할 수 있다.

분산 시스템은 CP이거나 AP여야 한다.

### 일관성 (Consistency)

- 사용자는 항상 최신 정보를 서비스 받는 것을 보장한다.
- 모든 사용자는 항상 동일한 데이터를 조회한다.

### 가용성 (Availablity)

- 서비스가 중단되지 않음을 보장한다.
- 일부 노드가 중단되어도 다른 노드들에게 영향을 주지 않아야 한다.

### 분할 내구성 (Partition Tolerance)

- 네트워크의 어느 한 지점과 연결이 끊어져도 서비스가 중단되지 않음을 보장한다.
- 네트워크 장애로 메시지를 손실하더라도 시스템은 정상 동작해야 한다.
- DB 노드 간의 통신 장애가 발생하더라도 동작해야한다.

## PACELC 이론

CAP 이론으로 부족한 부분을 보완하기 위해 네트워크 장애 상황과 정상 상황으로 나누어 설명하는 이론

네트워크 분할이 발생했다면 CAP 이론에서 제시한 가용성과 일관성 사이의 trade-off가, 그렇지 않다면 지연시간과 일관성 사이의 trade-off가 있음을 의미

### **네트워크 분할 상황 (CAP 이론)**

- 분할 상황은 물리적인 네트워크의 분할만을 의미하지 않고 노드끼리 데이터를 주고받을 때 타임아웃이 발생하는 모든 경우를 포함한다.
- 분할 상황에서는 단일 노드에 접근할 수 없기 때문에 일관성을 포기하고 가용성을 제공할지, 가용성을 포기하고 일관성을 유지할지의 정도를 결정해야 한다.

### **네트워크 정상 상황**

- 모든 노드에 업데이트를 반영해 일관성을 유지하기 위해 긴 대기/응답 시간을 가질지, 일관성을 포기하고 짧은 지연시간을 가질지의 정도를 결정해야 한다.

## Materialized View

### View

가상 테이블로 select 명령을 저장하고 있고, view 를 참조할 때마다 등록된 select 명령을 실행한다.

### Materialized View

select 명령의 결과 값이 많을수록 view 의 처리속도 저하 될 것, Materialized View 는 select 의 결과를 저장하고 다시 참조할 때 저장된 데이터를 그대로 사용한다.
또한, view 에 지정된 테이블의 데이터가 변경 될 경우 자동으로 select 명령을 실행하여 데이터 재집계
데이터가 자주 변경되지 않는다면 MV 고려
MySQL 의 경우 Materialized View 제공 안함