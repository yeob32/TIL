# MySql

## MySql 구조
* 서버 엔진 : 클라이언트(또는 사용자)가 Query를 요청했을때, Query Parsing과, 스토리지 엔진에 데이터를 요청하는 작업을 수행.                                      
* 스토리지 엔진 : 물리적 저장장치에서 데이터를 읽어오는 역할을 담당.

## 대표 스토리지 엔진
* InnoDB : 따로 스토리지 엔진을 명시하지 않으면 default 로 설정되는 스토리지 엔진이다. InnoDB는 transaction-safe 하며, 커밋과 롤백, 그리고 데이터 복구 기능을 제공하므로 데이터를 효과적으로 보호 할 수 있다.
InnoDB는 기본적으로 row-level locking 제공하며, 또한 데이터를 clustered index에 저장하여 PK 기반의 query의 I/O 비용을 줄인다. 또한 FK 제약을 제공하여 데이터 무결성을 보장한다.
* MyISAM : 트랜잭션을 지원하지 않고 table-level locking을 제공한다. 따라서 multi-thread 환경에서 성능이 저하 될 수 있다. 특정 세션이 테이블을 변경하는 동안 테이블 단위로 lock이 잡히기 때문이다.
텍스트 전문 검색(Fulltext Searching)과 지리정보 처리 기능도 지원되는데, 이를 사용할 시에는 파티셔닝을 사용할 수 없다는 단점이 있다.
* Archive : '로그 수집'에 적합한 엔진이다. 데이터가 메모리상에서 압축되고 압축된 상태로 디스크에 저장이 되기 때문에 row-level locking이 가능하다.
다만, 한번 INSERT된 데이터는 UPDATE, DELETE를 사용할 수 없으며 인덱스를 지원하지 않는다. 따라서 거의 가공하지 않을 원시 로그 데이터를 관리하는데에 효율적일 수 있고, 테이블 파티셔닝도 지원한다. 다만 트랜잭션은 지원하지 않는다.

### InnoDB
* 대용량 데이터 컨트롤 필요 시
* 트랜잭션 관리 및 복구 필요 시
* 정렬 구문 필요 시
* IUD 등이 빈번하게 발생하는 경우 (Row-Level-Rocking 때문)

### MyISAM
* 읽기 위주 작업 시
* 전문 검색 필요 시
* 트랜잭션 및 복구 x
* 한번에 대량의 데이터를 입력하는 배치성 테이블

## 정규화
- 정규화 -> 컬럼 분리 (인덱스 분리) -> 옵티마이저 최적화

### 외래키 (FK)
fk 걸면 부모 테이블 키 값 수정 또는 로우 삭제 시 에러 발생
cascade 걸어주면 삭제 가능


## Index
인덱스 생성 시 키 순서 -> 카디널리티가 높은 순으로 (ex 주민등록번호)
ex) idx(id, name, etc)
위의 인덱스로 검색 시 첫번째 키는 검색 조건에 꼭 들어가야 인덱스 탐

검색 시 유의사항
- 인덱스 컬럼의 값을 수정해서 검색하지 않기
    - ex) where price*10 = 1000;
- null 은 인덱스 안탐
- 자동 형변환을 지원하나, 정확한 데이터 타입으로 검색하기

### Index Scan
- Range Scan
    - 단일 건이 아닌 범위 검색, 검색 결과가 여러건
- Full Scan
    - 인덱스를 사용하지 않고 테이블 데이터를 처음부터 끝까지 읽어서 요청 작업을 처리
        - 발생 조건
            - 테이블의 레코드 건수가 적어서 인덱스를 통해 읽는것보다 직접 테이블을 읽는것이 더 빠르다고 판된될때
            - 인덱스 레인지스캔을 사용할 수 있는 쿼리라 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우
            - WHERE절이나 ON절에 사용할 수 있는 인덱스가 없을 경우

## B-Tree 인덱스
![B-Tree](https://cdn-images-1.medium.com/max/1600/1*pE4SEz7CprzFd7Zww-axfQ.jpeg)
- 이진탐색트리(Binary Search Tree)와 유사, 한 노드 당 자식 노드가 2개 이상 가능
- key 값으로 트리 구조를 이용해 데이터 탐색
- 삽입,제거,탐색 모두 시간복잡도 O(logN)

### 구성
- Root Node
- Branch Node
- Leaf Node

### Clusterd Index, Nonclustered Index
- Clusterd Index
    - 성능은 좋지만 테이블 당 한개만 생성 가능, 신중하게 생성해야함
    - 인덱스 생성 시 데이터 페이지 전체 재정렬
    - 대용량 데이터 인덱스 생성 시 부하 큼
    - 검색 속도 빠르나, 입력,수정,삭제는 느림
- Nonclustered
    - 인덱스 생성 시 별도의 페이지에 인덱스 구성
    - 인덱스 여러개 생성가능, 남용 시 시스템 성능 떨어질 수 있음
    - 검색 속도는 느리지만, 입력,수정,삭제는 빠름

### 식별 관계 매핑
- 식별 관계 (Identifying Relationship)
    - 기본 키 인덱스 활용 -> 별도의 인덱스 생성 필요 x
    - 부모 테이블의 기본키를 자식 테이블로 전파하여 기본키가 점점 늘어나게됨
        - SQL 복잡, 기본키 인덱스가 불필요하게 커질 수 있다.
    - 2개 이상의 컬럼을 합해서 복합 기본 키를 만들어야하는 경우가 많다.
    - 식별 관계의 자연 키 컬럼들이 자식에 손자까지 전파되면 변경이 힘들다.
- 비식별 관계 (Non-Identifying Relationship)
    - 기본 키를 비즈니스와 전혀 관계없는 대리 키를 주로 사용
        - 비즈니스가 변경되어도 유연한 대처 가능
    - 필수적 비식별 관계(Mandatory)
        - 외래 키에 NULL을 허용하지 않는다. 연관관계를 필수적으로 맺어야한다.
        - NOT NULL 로 항상 관계가 있다는 것을 보장 -> 내부조인만 사용해도 됨
    - 선택적 비식별 관계(Optional)
        - 외래 키에 NULL 허용, 연관관계를 맺을지 말지 선택
        - NULL 허용 -> 외부 조인 사용해야함.
- ORM 실무에서는 필수적 비식별 관계를 사용하고 기본 키는 Long 타입의 대리 키 사용을 선호

## References
- https://dzone.com/articles/database-btree-indexing-in-sqlite


