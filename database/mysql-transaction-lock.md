# MySQL

## 트랜잭션과 잠금

- 트랜잭션
    - 데이터 정합성을 보장하기 위한 기능
    - 작업 단위의 안정성,정합성 보장
    - 논리적인 작업 셋을 모두 완벽하게 처리하거나, 처리하지 못할 경우에는 모두 원 상태로 복구하는 작업의 일부분만 적용되는 현상이 발생하지 않도록 해주는 기능 (all or nothing)
    - ACID 특성 중 Atomicity(원자성) 에 해당
- 잠금(Lock)
    - 동시성을 제어하기 위한 기능
    - 한시점에 하나의 커넥션에서만 데이터 변경할 수 있게 해주는 역할

### 트랜잭션

- InnoDB 스토리지 엔진은 트랜잭션 지원, MyISAM,MEMORY 스토리지 엔진은 트랜잭션 지원 X
- 데이터베이스의 커넥션 개수는 제한적이기 때문에, 각 단위 작업이 커넥션을 소유하는 시간이 길어질수록 사용 가능한 커넥션 수 감소
    - 커넥션 획득 지연을 발생시켜 웹서버,DBMS 서버 모두를 위험하게 만들 수 있다.

### 트랜잭션이 보장해야 하는 ACID

- 원자성(Atomicity)
  - 한 트랜잭션 내에서 실행한 작업들은 하나의 작업으로 간주한다. 모두 성공 또는 모두 실패되어야 한다.
- 일관성(Consistency)
  - 모든 트랜잭션은 일관성 있는 데이타베이스 상태를 유지한다. 이를테면 DB에서 정한 무결성 조건을 항상 만족.
- 격리성(Isolation)
  - 동시에 실행되는 트랜잭션들이 서로 영향을 미치지 않도록 격리 해야한다.
- 지속성(Durability)
  - 트랜잭션을 성공적으로 마치면 그 결과가 항상 저장되어야 한다.

### 잠금

- 잠금은 크게 MySQL 엔진 레벨과, 스토리지 엔진 레벨로 나눌 수 있음
- MySQL 엔진 레벨의 잠금은 모든 스토리지 엔진에 영향을 미치지만, 스토리지 엔진 레벨의 잠금은 스토리지 엔진 간 상호 영향을 주지 않는다.

### MySQL 엔진의 락

- 글로벌 락 (Global Lock)
    - 영향을 미치는 범위는 MySQL 서버 전체로 가장 범위가 크다.
    - FLUSH TABLES WITH READ LOCK 명령으로 획득할 수 있음
    - 한 세션에서 글로벌 락을 획득하면 다른 세션에서 SELECT 를 제외한 대부분의 DDL 과 DML 은 해당 글로벌 락에 의해 대기하게 됨
    - 보통 MyISAM, MEMORY 테이블에서 mysqldump 유틸리티를 통해서 일관된 백업을 받을 때 사용하는데, InnoDB 가 기본 스토리지 엔진이 되면서, 가벼운 글로벌 락의 필요성이 생겼다.
    - MySQL 8.0 부터 백업 락이 도입되었음
- 테이블 락 (Table Lock)
    - 개별 테이블 단위로 설정되는 잠금
    - 묵시적/명시적 획득이 가능하나 명시적으로 획득할 일은 잘 없다.
    - 명시적 테이블 락
        - LOCK TABLES 테이블명 [read | write] 명령으로 특정 테이블 락
        - 획득한 잠금은 UNLOCK TABLES 명령으로 잠금 해제 가능
    - 묵시적 테이블 락
        - MyISAM 이나 MEMORY 테이블의 데이터를 변경하는 쿼리 실행 시 발생
        - 쿼리가 실행되는 동안 자동으로 획득 되었다가 쿼리가 완료된 후 자동 해제
        - InnoDB 스토리지 엔진 테이블의 경우 대부분의 데이터 변경(DML) 은 레코드 기반의 잠금을 사용하기 때문에 묵시적 락은 발생하지 않음
        - 스키마 변경(DDL)을 막기 위해서만 테이블 락 사용
- 네임드 락 (Named Lock)
    - GET_LOCK() 함수를 이용하여 지정한 문자열(String)을 통해 락을 획득하고 반납하는 잠금 기능
    - Redis 등을 사용해서 분산락 구현이 가능하기 잘 사용하지는 않음
        - 별도의 인프라 구축에 대한 비용을 줄이고 원래 사용중인 DB 인프라를 사용한다는 장점은 있음
- 메타데이터 락 (Metadata Lock)
    - 데이터베이스 객체(테이블,뷰) 의 이름이나 구조를 변경하는 경우 획득하는 잠금
    - 명시적으로 획득할 수 없고, 테이블 명세 변경 시 자동 획득

#### InnoDB 스토리지 엔진의 락

- InnoDB 는 레코드 기반의 잠금을 지원하기 때문에 MyISAM 보다 훨씬 뛰어난 동시성 처리를 제공
- MySQL 5.1 에서는 InnoDB 의 트랜잭션과 잠금, 그리고 잠금 대기중인 트랜잭션의 목록을 조회할 수 있음
    - information_schema 데이터베이스의 INNODB_TRX, INNODB_LOCKS, INNODB_LOCK_WAITS 테이블을 조인해서 조회하면 현재 어떤 트랜잭션이 잠금을 대기하고 있고 해당
      잠금을 어느 트랜잭션이 가지고 있는지 확인 가능
    - 장시간 잠금을 가지고 있는 클라이언트를 찾아 종료시킬 수도 있음
- InnoDB 의 잠금은 레코드를 잠그는 것이 아니라 인덱스를 잠그기 때문에 UPDATE 문 등에서 적절한 인덱스가 없다면 테이블을 풀스캔하면서 모든 레코드를 잠글 수 있기 때문에 주의해야함

#### 락 적용 요소에 따른 분류

- 공유 잠금 (Shared Lock)
    - Row Level Lock
    - 특정 Row 를 읽을 때 사용, Read Lock 이라고도 함
    - 다른 트랜잭션이 해당 Row 에 대해 베타 락은 획득이 불가능하지만, 공유 락은 획득 가능
    - 조회한 데이터가 트랜잭션 안에서 변경되지 않음을 보장 -> 읽기만 가능
    - SELECT ... Lock IN SHARE MODE (8.0 부터는 FOR SHARE)
- 베타적 잠금 (Exclusive Lock)
    - Row Level Lock
    - 특정 Row 를 변경 혹은 삭제하고자 할 때 사용, Write Lock 이라고도 함
    - 데이터를 변경하고자 할 때 사용되며, 트랜잭션이 완료될 때까지 유지됨
    - 락이 걸려 다른 트랜잭션에서 공유 락/베타 락 모두 획득하지 못하게 되는 블로킹(Blocking) 상태가 됨
    - 읽기/쓰기 작업 불가능
    - SELECT ... FOR UPDATE

#### 블로킹과 교착 상태(Deadlock)
- 블로킹
  - Lock 경합이 발생하여 특정 세션이 작업을 진행하지 못하고 멈춰 선 상태. 이를 해소하기 위한 방법으로는 커밋 또는 롤백 뿐임
  - Lock 에 의한 성능 저하 최소화 방안
    - 트랜잭션의 원자성을 훼손하지 않는 선에서 트랜잭션을 가능한 짧게 정의한다.
    - 같은 데이터를 갱신하는 트랜잭션이 동시에 수행되지 않도록 설계하는 것이 중요, 특히 대용량 갱신 작업을 주간에 수행하는 것은 지양한다.
      - 주간에 대용량 갱신 작업을 수행해야 한다면, 블로킹 현상에 의해 사용자가 무한정 기다리지 않도록 적절한 프로그래밍 기법을 도입한다.
    - 트랜잭션 격리성 수준을 불필요하게 상향 조정하지 않는다.
    - SQL 문장이 가장 빠른 시간 내에 처리를 완료하도록 하는 것이 Lock 튜닝의 기본이며 효과도 가장 확실함
- 교착 상태
  - 두 세션이 각각 Lock 을 설정한 리소스를 서로 접근하려고 진행하는 상황으로, 여러 테이블을 엑세스하면서 발생하는 교착상태는 테이블 접근 순서를 같게 처리하면 피할 수 있다. 

### InnoDB 엔진 락의 종류

- 레코드 락(Record Lock)
    - 레코드 자체만 잠그는 락
        - InnoDB 엔진의 특징은 레코드 자체가 아니라 인덱스의 레코드를 잠그는 것
        - 인덱스가 없는 테이블이더라도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금 설정
    - 보조 인덱스를 이용한 변경 작업은 갭 락과 넥스크 키 락을 걸지만, PK, Unique Index 에서의 변경 작업은 레코드 락을 사용
- 갭 락(Gap Lock)
    - 레코드와 바로 인접한 레코드 사이의 간격만을 잠근다.
    - 레코드와 레코드 사이 간격에 새로운 레코드가 생성되는 것을 제어하는 역할
    - id = 2 인 row 와 id = 5 인 row 가 있을 때와 같이 중간에 비어있는 레코드의 갭
- 넥스트 키 락(Next Key Lock)
    - 레코드 락과 갭 락을 합친 것과 같은 형태
    - InnoDB 의 갭 락과 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주목적
        - 그런데 의외로 해당 락으로 인해 데드락이 발생하거나 다른 트랜잭션을 기다리게 만드는 일이 자주 발생하므로, 가능하다면 바이너리 로그 포맷을 ROW 형태로 바꿔서 해당 락을 줄이는 것이 좋다.
        - MySQL 8.0 에서는 ROW 포맷의 바이너리 로그가 기본 설정으로 변경됐다.
- 자동 증가 락(Auto Increment Lock)
    - 순서대로 증가하는 일련번호 값을 채번하기 위한 테이블 수준의 잠금
    - INSERT, REPLACE 와 같이 새로운 레코드를 저장하는 쿼리에서만 필요
    - 트랜잭션과 관계 없이 AUTO_INCREMENT 값을 가져오는 순간만 락이 걸렸다가 즉시 해제됨
    - MySQL 5.1 이상부터는 innodb_autoinc_lock_mode 라는 시스템 변수를 이용하여 자동 증가 락의 작동 방식 변경 가능
        - innodb_autoinc_lock_mode=0
            - MySQL 5.0 과 동일한 잠금 방식으로 모든 INSERT 문장은 자동 증가 락을 사용
        - innodb_autoinc_lock_mode=1
            - INSERT 되는 레코드의 건수를 정확히 예측할 수 있을 때는 자동 증가 락을 사용하지 않고, 훨씬 가볍고 빠른 래치(뮤텍스)를 이용하여 처리
        - innodb_autoinc_lock_mode=2
            - 항상 래치(뮤텍스)를 이용해 처리한다. MySQL 8.0의 바이너리 로그 포맷이 기본 ROW 포맷으로 변경되면서 해당 설정도 2가 기본값이 되었음

#### InnoDB 엔진의 데드락(Dead Lock) 처리

- InnoDB는 데드락 감지를 설정을 디폴트로 사용
- 데드락 감지 기능에 의해서 데드락으로 감지되면 2개의 트랜잭션 중 데이터 변화가 적은 트랜잭션을 rollback 시켜 데드락을 해소
- 높은 동시성을 사용하는 고성능 시스템에서는 데드락 감지기능은 속도 저하의 원인이 될 수 있음
    - 해당 경우에는 데드락 감지기능을 사용하기 보다는 innodb_lock_wait_timeout 사용을 권장하고 있음
        - innodb_lock_wait_timeout 은 row lock 을 걸고 특정시간 이상 소요 시 자동으로 락을 해재해버리는 매커니즘

### 격리 수준 (isolation level)

- 여러 트랜잭션이 동시에 처리될 때, 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지를 결정하는 것
- READ UNCOMMITTED
    - 각 트랜잭션의 변경 내용이 커밋이나 롤백 여부와 상관 없이 다른 트랜잭션에서 조회 가능
    - RDBMS 표준에서는 격리 수준으로 인정하지 않을 정도로 정합성에 문제가 많음
    - DIRTY READ 발생
- READ COMMITTED
    - 커밋된 데이터만 다른 트랜잭션에서 조회 가능
    - 해당 테이블이 아니라 언두 영역에 백업된 레코드에서 데이터를 가져오기 때문에 커밋되기 전 데이터를 읽을 수 있음
    - 하나의 트랜잭션 내에서 같은 SELECT 쿼리를 실행했을 경우 그사이에 데이터가 바뀌면 결과가 달라진다.
        - REPEATABLE READ 정합성에 어긋남
    - Oracle 의 기본 격리 수준
- REPEATABLE READ
    - InnoDB 스토리지 엔진은 트랜잭션이 Rollback 될 경우를 대비하여 변경 전 데이터를 언두(UNDO) 영역에 백업해두고 실제 레코드 값을 변경하게 됨
    - 그리고 트랜잭션이 COMMIT 을 하기전에 다른 세션에서 해당 데이터를 조회 시 언두 영역을 참조하여 이전 값을 보여주는데, 이를 MVCC (Multi Version Concurrency Control)
      라고 함
    - READ COMMITTED 와의 차이는 언두 영역에 백업된 레코드의 여러 버전 중에서 몇 번째 이전 버전까지 찾아 들으가야 하느냐에 있음
    - 모든 트랜잭션은 순차적으로 증가하는 고유한 트랜잭션 번호를 갖고 있음. 언두 영역의 모든 백업 레코드에는 변경을 발생시킨 트랜잭션의 번호가 포함되어 있다. 언두 영역의 데이터는 전체가 보관될 필요는 없고,
      특정 트랜잭션 번호의 구간 내에서 백업되기만 하면 된다.
        - 예를 들어, 10번이라는 트랜잭션에서 반복적으로 데이터를 조회하는 경우, 트랜잭션 번호가 10보다 작은 언두 데이터만 조회하도록 하는 것
    - SELECT ... FOR UPDATE 쿼리는 SELECT 하는 레코드에 쓰기 잠금을 걸어야 하는데, 언두 레코드에는 잠금을 걸 수 없어 현재 레코드의 값을 가져와야만 한다. 이렇게 되면 조회할 때마다
      값이 보였다 안보였따 할 수 있는데, 이런 현상을 PHANTOM READ 라고 함
    - REPEATABLE READ 격리 수준에서는 기본적으로 SELECT 쿼리 문장도 트랜잭션 범위 내에서만 동작함
        - START TRANSACTION(또는 BEGIN) 명령으로 트랜잭션을 시작한 상태에서 동일한 쿼리를 계속 반복해서 실행하더라도 동일한 결과값만 조회됨
    - InnoDB 스토리지 엔진에서는 갭 락과 넥스트 키 락 덕분에 PHANTOM READ 가 발생하지 않음
        - SERIALIZABLE 격리 수준을 사용할 필요성 없음
    - MySQL InnoDB 스토리지 엔진의 기본 격리 수준
- SERIALIZABLE
    - 가장 단순하면서 가장 엄격한 격리 수준
    - 읽기 작업도 공유 잠금을 획득해야한 하며, 동시에 다른 트랜잭션은 해당 레코드를 변경할 수 없음
    - 동시 처리 성능이 가장 떨어짐

### 격리 수준에 따른 부정합 문제
- Dirty Read
  - 다른 트랜잭션에 의해 수정됐지만, 아직 커밋되지 않은 데이터를 읽는 것
- Non-Repeatable Read
  - 한 트랜잭션 내에서 같은 쿼리를 두 번 수행했는데, 그 사이에 다른 트랜잭션이 값을 수정 또는 삭제하는 바람에 두 쿼리 결과가 다르게 나타나는 것
- Phantom Read
  - 한 트랜잭션 내에서 같은 쿼리를 두 번 수행했는데, 첫 번째 쿼리에서 없던 유령 레코드가 두 번째 쿼리에서 나타나는 것

|                  | DIRTY READ | NON-REPEATABLE READ | PHANTOM READ    |
|------------------|------------|---------------------|-----------------|
| READ UNCOMMITTED | 발생         | 발생                  | 발생              |
| READ COMMITTED   | 없음         | 발생                  | 발생              |
| REPEATABLE READ  | 없음         | 없음                  | 발생(InnoDB 는 없음) |
| SERIALIZABLE     | 없음         | 없음                  | 없음              |

## 로그 선행 기록 (Write Ahead Logging, WAL)
- 데이터 무결성 보장 방법
- 변경 내용을 설명하는 로그 레코드를 영구적 저장소에 먼저 기록한 후에 데이터 파일(테이블,인덱스)의 변경 내용을 작성한다는 원칙
    - 트랜잭션 발생 시 로그를 남기고 데이터가 쌓이면 이를 flush 해서 데이터베이스의 디스크에 데이터 블록 형태로 write
- 모든 요청에 대한 동일한 데이터 조회로 일관성 보장
- 이미 로그에 기입되었기 때문에 원자성 보장

### REDO, UNDO
