# MySQL Index

## Index 란
- 책의 마지막에 있는 찾아보기 또는 색인과 비슷한 기능
- 책의 내용은 데이터 파일, 알아낸 책 페이지 번호는 데이터 파일에 저장된 레코드의 주소로 비유
- 찾아보기와 인덱스 둘다 정렬 되어있음, 따라서 인덱스는 정렬을 통해 쓰기(INSERT, UPDATE, DELETE) 성능을 희생하여 읽기 성능을 향상시킴
- UPDATE 작업을 위해 적절히 인덱스가 준비되어 있지 않다면, 인덱스가 없는 조건으로 락을 걸면 전체 데이터가 잠기게 됨
  - InnoDB 의 잠금은 레코드를 잠그는 것이 아니라, 인덱스를 잠그는 것 
  - 클라이언트 간의 동시성이 떨어지고, 데드락 발생 가능성

## B Tree
- 이진트리(Binary Tree) 의 단점인 선형 구조(불균형)로 데이터가 저장될 수 있는 현상을 해결한 알고리즘
- Binary Tree 가 아닌 Balance Tree
- B-Tree, B+Tree, B*Tree
- 노드는 페이지라고도 표현함

### B+Tree
- B-Tree 와 기본 구조 동일
- B+Tree 는 리프 노드들 간 링크드리스트 형태로 연결되어 있음
  - 데이터를 범위 검색할 때 한 번 리프노드에서 특정 노드를 찾으면 이후 브랜치 노드의 개입 없이 데이터 검색이 가능하다는 장점

### B-Tree Index 특징
- 범용적으로 사용되는 인덱스 알고리즘
- 트리 구조
  - 노드(페이지) 를 3계층으로 구분 
  - 최상위,중간,최하단 각각 루트 노드(Root node), 브랜치 노드(Branch node), 리프 노드(Leaf node) 로 구성되어 있음
  - 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주소값을 가지고 있음
- 각 노드 인덱스의 키 값은 모두 정렬되어 있지만, 데이터 파일의 레코드는 정렬되어 있지 않음
  - 레코드를 전혀 변경,삭제하지 않는다면 순서대로 저장되지만, 레코드가 삭제되어 빈 공간이 생기면 INSERT 는 빈 공간을 활용하여 저장
  - InnoDB 테이블은 기본적으로 레코드가 클러스터링되어 디스크에 저장되므로 PK 순으로 정렬되어 저장
- InnoDB 테이블에서는 리프 노드가 레코드 주소 값으로 논리적인 주소인 PK 값을 가진다.
  - 클러스터링 인덱스(PK) 의 리프 노드는 실제 데이터 파일의 주소를 갖고 있음
  - 그렇기 때문에 InnoDB 스토리지 엔진에서는 모든 Secondary 인덱스 검색에서 데이터 레코드를 읽기 위해서는 반드시 PK 를 저장하고 있는 B-Tree 를 다시 한번 검색해야함
  - 즉, Secondary Index 의 리프 노드의 PK 값을 조회 후 Clustered index 의 인덱스 트리 검색하여 실제 데이터 파일 주소를 찾음 

#### 논리적인 주소를 가져서 오히려 성능저하가 아닐지
- InnoDB 스토리지 엔진에서는 세컨더리 인덱스의 페이지에서 클러스터링 인덱스를 다시 한 번 검색해야하기 때문에 성능이 저하 될 수 있다.
  - MyISAM 에서는 INSERT, UPDATE 가 발생하더라도 데이터가 처음에 자장된 물리적인 위치는 바뀌지 않음. 때문에 추후 INSERT, UPDATE 가 발생하게 되면 데이터들의 물리적인 위치가 이곳저것에 흩뿌려지는 상황이 발생하고 이는 Random I/O 를 발생시킴
  - InnoDB 의 경우 INSERT,UPDATE,DELETE 시 클러스터링 인덱스의 값이 바뀌면 데이터의 물리적인 위치를 바꾸면서 데이터베이스의 쓰기 성능을 희생시키면서 검색 성능을 향상 시킴
    - 클러스터링 인덱스에 따라 순차적으로 물리적인 위치를 가지게 되면 Sequential I/O 가 발생해 검색 성능의 향상을 얻게됨

### B-Tree Index 추가 및 삭제 동작
- 테이블의 레코드를 저장하거나 변경하는 경우 인덱스 키 추가나 삭제 작업 발생
- 인덱스 키 추가
  - 새로운 키 값이 B-Tree 에 저장될 때 InnoDB 의 경우 인덱스 키 추가 작업을 지연시켜서 나중에 처리할 수 있음
  - PK 나 유니크 인덱스의 경우에는 중복 체크가 필요하기 때문에, 즉시 B-Tree 에 추가하거나 삭제해줘야함
  - 인덱스 추가 지연 방법은 InnoDB 의 체인지 버퍼를 통해 가능
- 인덱스 키 삭제
  - 키 값 삭제는 해당 키 값이 저장된 B-Tree 의 리프 노드를 찾은 다음, 삭제 마크를 해주면 작업이 완료됨
  - 인덱스 키 삭제를 위해 마킹하는 작업도 디스크 I/O 에 해당되므로 비싼 작업임
  - 체인지버퍼 통해 지연 처리 가능
- 인덱스 키 변경
  - 인덱스의 키 값은 그 값에 따라 저장될 리프 노드의 위치가 결정되므로, 단순히 인덱스 상의 키 값을 변경하는 것은 불가능
  - B-Tree 의 키 값 변경 작업은 먼저 키 값을 삭제한 후, 다시 새로운 키 값을 추가하는 형태로 처리
  - 체인지버퍼 통해 지연 처리 가능
- 인덱스 키 검색
  - 인덱스 검색은 루트 노드 -> 브랜치 노드 -> 리프 노드까지 이동하면서 비교 작업을 수행, 이를 트리 탐색이라고 함
  - 이는 SELECT 뿐만 아니라, UPDATE, DELETE 처리를 위해서도 사용됨

#### B-Tree 인덱스 트리 탐색 
  - B-Tree 인덱스 타는 경우
    - 100% 일치를 따지는 조건절
    - 값의 앞부분 일치를 따지는 조건절
    - 부등호(<, >) 비교 조건
  - B-Tree 인덱스 타지 못하는 경우
    - 키 값의 뒷부분 일치를 따지는 조건절
    - 키 값에 변형이 가해진 경우의 조건절
  
### B-Tree 인덱스 성능
- 인덱스를 구성하는 컬럼의 크기, 레코드의 수, 유니크한 인덱스 키값의 개수 등에 의해 검색이나 변경 작업의 성능이 영향 받음
- 인덱스 키 값의 크기
  - 페이지(Page) 또는 블록(Block)
    - InnoDB 스토리지 엔진은 디스크에 데이터를 저장하는 기본 단위
    - 디스크의 모든 읽기 및 쓰기 작업 최소 단위
    - InnoDB 버퍼풀에서 버퍼링하는 단위
  - 인덱스도 페이지 단위로 관리, 푸트,브랜치,리프 노드를 구분하는 기준이 페이지
  - B-Tree 는 Binary Tree 가 아닌 Balanced Tree 임 즉, 자식 노드의 개수는 가변적이며, 자식 노드를 몇개까지 가질 수 있는지는 인덱스의 페이지 크기와 키 값의 크기에 따라 결정됨
  - 인덱스를 구성하는 키 값의 크기가 커지면, 디스크로부터 읽어야하는 횟수가 늘어나고 그만큼 느려진다는 것을 의미
- 선택도(카디날리티)
  - 모든 인덱스 키 값 가운데 유니크한 값의 개수
  - 인덱스에서 선택선택도(Selectivity) 또는 카디날리티(Cardinality) 는 거의 같은 의미로 사용됨
  - 인덱스 키 값 가운데 중복된 값이 많아질수록 검색 대상이 많아져서 인덱스의 효율성이 줄게됨
- 읽어야하는 레코드의 건수
  - 인덱스를 통해 테이블의 레코드를 읽는 것은 인덱스를 거치지 않고, 바로 테이블의 레코드를 읽는 것보다 높은 비용이 드는 작업
  - 인덱스를 통해 읽어야할 레코드의 건수가 전체 테이블의 20~25% 를 넘어서면 인덱스를 사용하지 않고 모두 직접 읽어서 필요한 레코드만 가려내는(필터링) 방식으로 처리하는 것이 효율적

### 스캔 종류
- 인덱스 스캔
  - 인덱스(Memory) 를 통해 테이블(Disk) 데이터 접근
- 테이블 스캔
  - 인덱스를 거치지 않고 테이블의 데이터로 직접 접근

### B-Tree 인덱스 스캔
- 스캔 과정
  - 인덱스에서 조건을 만족하는 값이 저장된 위치를 찾는다 (인덱스 탐색(Index seek))
  - 탐색된 위치부터 필요한 만큼 인덱스를 차례대로 쭉 읽는다 (인덱스 스캔(Index scan)), 위의 과정과 통틀어서 인덱스 스캔이라고도 함
  - 디스크 I/O 를 수행하여 읽어들인 인덱스 키와 레코드 주소를 이용해 레코드가 저장된 페이지를 가져오고, 최종 레코드를 읽어온다.
- 인덱스 레인지 스캔(Index Range scan)
  - 인덱스 접근 방법 중 가장 대표적인 접근 방법으로 다른 스캔 방식에 비해 비교적 빠른 방법
    - 범위의 시작 시점을 찾는다면 리프 노드들은 연결되어 있기 때문에 종료되는 조건까지 리프 노드를 읽으면 됨
  - 인덱스를 통해 B+Tree를 수직 탐색 후 리프 노드 레벨에서 필요한 범위까지 탐색하는 방식
  - scan type : range
- 인덱스 풀 스캔(Index Full scan)
  - 실행할 쿼리에 인덱스가 없을 때 발생, 쿼리에 인덱스가 없기 때문에 인덱스 트리를 전부 탐색함
  - 인덱스를 사용하지만 복합 인덱스일 경우 인덱스 생성 시 가장 먼저 명시한 컬럼으로 조회하지 않는 경우에도 인덱스 타지 않음
    - 복합 인덱스의 경우 문자열 순서대로 조합하여 생성하기 때문 
      - ex) (id, name) 으로 인덱스를 걸었다면 where 절에 name 만 검색 시 인덱스 안탐
  - scan type : index(인덱스 전체 탐색) 또는 ALL (테이블 전체 탐색)
- 루즈 인덱스 스캔(Loose Index scan)
  - 인덱스 탐색 - 스캔 - 디스크 I/O 과정에서 인덱스 스캔 중 중간중간 필요 없는 인덱스 키 값을 건너뛰는 방식
  - 집계함수(GROUP BY 또는 MAX(), MIN()) 사용에 최적화
  - scan type : range
- 인덱스 스킵 스캔(Index Skip scan)
  - 원래 복합키 인덱스는 순서가 중요한데, MySQL 8.x 부터는 앞의 인덱스가 생략되어도 인덱스 사용이 가능함 
  - 인덱스 스킵 스캔을 사용하려면 다음 설정 필요
    - > SET optimizer_switch='skip_scan=on';

### 커버링 인덱스
- 쿼리에 사용되는 컬럼이 인덱스 컬럼만 존재할 경우 디스크 I/O 가 발생하지 않게 되는데 이를 커버링 인덱스라고 함
- 인덱스는 메모리에서 관리하고, 데이터는 디스크에서 관리함
  - 인덱스 트리에서 찾은 노드는 디스크로부터 데이터를 읽어와 사용자에게 쿼리 결과를 주는데, 사용되는 컬럼이 인덱스 컬럼이라면 굳이 디스크 I/O 가 발생할 필요 없음
- 디스크 I/O 가 발생하지 않기 때문에 디스크 I/O 가 일어나는 쿼리보다 최적화됨

#### 예시
- 해당 예시의 서브 쿼리는 인덱스만 명시되었기 떄문에 데이터 블록을 보지 않고, 메모리를 사용하여 디스크 I/O 가 줄어들게 됨
```
select a.* from (
    select id from item
    where created like '2023%'
    limit 100000, 10
) b join item a on b.id = a.id; 
```

### B-Tree 인덱스의 가용성과 효율성
- 조건이 동등 비교인지 아니면 크거나 작다와 같은 범위 조건인지에 따라 각 인덱스 컬럼의 활용 형태가 달라지며, 그 효율 또한 달라짐
```
SELECT * FROM dept_emp
		WHERE dept_no='d002' AND emp_no >= 10114;
```
- 인덱스 케이스로 가정
  - 케이스 A : dept_no, emp_no
  - 케이스 B : emp_no, dept_no
- 케이스 A 의 경우 dept_no가 'd002' 가 아닐 때까지 인덱스를 그냥 쭉 읽기만 하면 됨
  - 레코드를 찾는데 꼭 필요한 비교 작업만 수행한 것이므로 상당히 효율적으로 인덱스 이용한 것
- 케이스 B 의 경우 우선 emp_no>=10144 AND dept_no='d002'인 레코드를 찾은 다음, 모든 레코드에 대해 dept_no='d002' 인지 비교해야됨
  - 인덱스를 통해 읽은 레코드가 나머지 조건에 맞는지 비교하면서 취사선택하는 작업을 필터링이라고 함
- 케이스 A 를 작업 범위 결정 조건이라고 하고, B 를 필터링 또는 체크 조건이라고 함
- 작업 범위를 결정하는 조건은 많으면 많을수록 쿼리의 처리 성능을 높이지만, 체크 조건은 많다고 해서 쿼리의 처리 성능을 높이지는 못함

#### 가용성, 효율성 판단
- B-Tree 인덱스 특성상 다음 조건에서는 작업 범위 결정 조건을 사용할 수 없고, 경우에 따라서는 체크 조건으로 인덱스를 사용할 수는 있음
  - NOT-EQUAL 로 비교된 경우 ("<>", "NOT IN", "NOT BETWEEN", "IS NOT NULL")
  - LIKE '%??' (앞부분 비교가 아닌 뒷부분 일치) 형태로 문자열 패턴이 비교된 경우
  - 스토어드 함수나 다른 연산자로 인덱스 칼럼이 변형된 후 비교된 경우 (ex. SUBSTRING, DAYOFMONTH)
  - NOT-DETERMINISTIC 속성의 스토어드 함수가 비교 조건에 사용된 경우
  - 데이터 타입이 서로 다른 비교(인덱스 칼럼의 타입을 변환해야 비교가 가능한 경우)
  - 문자열 데이터 타입의 콜레이션이 다른 경우(UTF8, EUCKR)

### 클러스터링 인덱스
- 테이블의 레코드를 비슷한 것들끼리 묶어서 저장하는 형태
  - 이는 주로 비슷한 값들을 동시에 조회하는 경우가 많다는 점에서 착안
- 프라이머리 키(PK) 값에 의해 레코드의 저장 위치가 결정됨
- PK 값이 변경되면 해당 레코드의 물리적인 저장 위치가 변경됨
  - InnoDB 와 같이 항상 클러스터링 인덱스로 저장되는 테이블은 PK 기반 검색이 매우 빠르다, 대신 레코드의 저장이나 PK 변경이 상대적으로 느림

#### 장단점
- 장점
  - PK 로 검색할 때 처리 성능이 매우 빠름
    - 특히 범위 검색의 경우 매우 빠름
  - 테이블의 모든 세컨더리 인덱스가 PK 를 가지고 있기 때문에 인덱스만으로 처리될 수 있는 경우가 많음
    - 커버링 인덱스
- 단점
  - 테이블의 모든 세컨더리 인덱스가 클러스터링 키를 갖기 때문에 클러스터링 키 값의 크기가 클 경우 전체적으로 인덱스 크기가 커짐
    - 인덱스 크기가 커지면 페이지에 담을 수 있는 레코드의 개수가 적어지고 하나의 명령으로 여러 개의 페이지를 읽게 됨
  - 세컨더리 인덱스를 통해 검색할 때 PK 로 다시 한 번 검색해야하므로 처리 성능 느려짐
  - INSERT 할 때 레코드의 저장위치가 결정되기 때문에, 저장위치를 결정하는 작업이 추가적으로 수행돼 처리 성능 느려짐
  - PK 를 변경할 때 레코드를 DELETE 하고 INSERT 하는 작업이 필요하기 때문에 처리 성능 느림

### 유니크 인덱스
- 유니크는 인덱스라기보다는 제약 조건에 가까움
- 유니크 제약을 설정하면 자동으로 인덱스가 생성됨
- PK 는 NULL 을 허용하지 않는 유니크 속성이 자동 부여됨

### 유니크 인덱스 vs 세컨더리 인덱스
- 인덱스 읽기
  - 유니크하지 않은 세컨더리 인덱스에서 한 번 더 해야하는 작업은 디스크 읽기가 아니라 CPU 에서 컬럼 값을 비교하는 작업이기 때문에 성능상 영향이 거의 없음
  - 디스크 읽기가 아닌 InnoDB 버퍼 풀에서 읽어야할 레코드가 조금 더 많아도 성능상 큰 차이가 없음
- 인덱스 쓰기
  - 새로운 레코드가 INSERT 되거나 인덱스 컬럼의 값이 변경되는 경우에는 인덱스 쓰기 작업이 필요함
  - 유니크하지 않은 세컨더리 인덱스의 쓰기가 더 빠름
    - 유니크 인덱스의 키 값을 쓸 때에는 중복된 값이 있는지 없는지 체크하는 과정이 한 단계 더 필요

#### 중복 체크가 오래 걸리는 이유
- MySQL 은 유니크 인덱스에서 중복된 값을 체크할 때에는 읽기 잠금을 사용하고, 쓰기를 할 때에는 쓰기 잠금을 사용하는데 이 과정에서 데드락(Deadlock) 이 자주 발생
- 또한 인덱스 키의 저장을 버퍼링하기 위해 체인지버퍼(Change Buffer) 가 사용되는데, 유니크 인덱스는 중복 체크를 해야하기 때문에 버퍼링하지 못합니다.

### 외래키
- InnoDB 스토리지 엔진에서만 생성 가능, 외래키 제약이 설정되면 자동으로 연관되는 테이블 컬럼의 인덱스까지 생성됨
- 외래키가 제거되지 않은 상태에서는 자동으로 생성된 인덱스 삭제 불가
- 특성
  - 테이블의 변경(쓰기 잠금)이 발생하는 경우에만 잠금 경합(잠금 대기) 발생
  - 외래키와 연관되지 않은 컬럼의 변경은 최대한 잠금 경합(잠금 대기)를 발생시키지 않음
- 외래키를 생성하면 자식 테이블 레코드 추가 시 해당 참조키가 부모 테이블에 있는지 확인하게 됨
  - 해당 작업을 위해 연관 테이블에 읽기 잠금을 건다
  - 이렇게 잠금이 다른 테이블로 확장되면 그만큼 전체적으로 쿼리의 동시처리에 영향을 미치므로 동시성이 떨어지게 됨
    - 모델링 시 동시처리 성능과 같은 부분들도 고려해서 모델링해야한다
